# test_repo
My first repository in GitHub!
This is my first commit!

here will be my attempts to prepare for the exam (exam before entering the university) in python

In this file, I am going to briefly describe what each task is presented on the exam. This will help me get a general picture of the tasks: both those that need to be solved in python, and those that need to be solved manually.

План на 10 класс:
1. подучить синтаксис питона
2. Закончить писать файл до конца учебного года


# Задание №1
В этом задании необходимо: 1.сопоставить схему каких-то "дорог" с таблицей длинн этих дорог; 2.выполнить требуемое задание (посчитать, какой из возможных путей наикратчайший/выписать длину пути из одного пункта в другой). Главное в этом задании - не запутаться в первом этапе и, вникнув в поставленную задачу, грамотно выполнить второй этап.

Что мне нужно для закрепления этого задания: 
1. прорешать все возможные типы этого задания (взять варианты с разных сайтов, сборников, просмотреть видосы, где прорешивают это задание в большом количестве), придрочиться к нему
2. изучить алгоритм декстера
3. периодически возвращаться к нему (раз в месяц-два), дабы освежать в памяти
4. прорешать до конца года как минимум 5 таких заданий

# Задание №2!
В этом задании необходимо составить таблицу истинности логических выражений, опираясь на условие в задаче. Сопоставить солбцы из нее со столбцами в таблице из самого задания (на этом моменте мне нужно быть особенно внимательной, проверять все совпадения цифр по строкам,проверять столбцы на одинаковость (2 однаковых столба НЕ может быть) ). 

Если в выражении нет скобок, сначала выполняются все операции "НЕ", затем - "И", потом - "ИЛИ", "импликация", и последняя - "эквивалентность". 

-Логиеская сумма A + B + C +...равна нулю только тогда, когда все слогаемые равны нулю, а в остальных случаях равна 1
-Логическое произведение A * B * C *...равно 1 только тогда, когда все сомножители одновременно равны 1, а в остальных случаях произведение равно 0
-Логическое следование (импликация) А <= B равна 0 только когда А (посылка) истина, а В (следствие) ложно
-Эквивалентность А == В равна 1 только когда оба значения одновременно равны 0 или одновременно равны 1

Что мне нужно для закрепления этого задания:
1. зазубрить все условные знаки (их перечень есть в файле с решениями этого задания)
2. уточнить, по каким признакам нужно сопоставлять столбцы из полученной талбицы со столбами из условия (на сайте полякова есть файл с полным объяснением второго задания)
3. додорочить разные варианты этой задачи до автоматизма (выполнение задания занимает не больше 3х минут)
4. проршать до конца года как минимум 20 таких заданий(3)

# Задание №3!
В этом номере проверяется умение работать с xl-вскими таблицами (выставлять в них фильтры, поиск ("найти и выделить" в правом верхнем углу), складывать числа, не заполняя для этого ячеек (при выделении необходимых столбцов справа внизу есть сумма цифр из этого столба)).
Необходимо обратить особое внимание на получение ответа и на сам вопрос, если он того требудет, узнать конкретные единицы измерения, вычесть из поступления продажу и т.д.
Что мне нужно для закрепления этого задания:
1. просмотреть еще несколько видео по разным вариантам решения этого задания
2. прорешать много задачек и разбираться в xl-e как боженька
3. прорешать до конца года 5 заданий

# Задание №4
Это задание представляет собой задачи на кодировку определённых букв с соблюдением условия ФАНО(т.е. каждое закодированное слово не может являться началом другого закодированного слова). 
У этого номера есть 2 вида:
Выбор кода при неиспользуемых сигналах; Передача информации. Выбор кода
Что мне нужно для закрепления этого задания:
1. прорешать до конца года 10 заданий

# Задание №5!
В этом задании нужно записать некий алгоритм, который по итогу выдаст нам новое требуемое число.
s =bin(n)[2:].zfill(8) - восьмибитная(8) двоичная(bin(n)) запись([]) числа n
Бит чётности - дополнительный контрольный бит, который добавляется к двоичному коду так, чтобы количество единиц в полученном двоичном коде стало чётным (было чётное количеств единиц -дописывается 0, нечётное - 1).
При добавлении к двоичной записи числа нуля справа число увеличитается в 2 раза.
Чтобы отбросить последнюю цифру в двоичной записи, нужно разделить число на 2 нацело.(//)
def perevod3(num):#перевод из 10чной систем счисления в троичную
    num3 = ''
    while num > 0:
        num3 = str(num % 3) + num3
        num // = 3
    return num3
Чтобы посмтроить восьмибитную двоичную запись числа(дописать ведущие 0 до того, пока в числе не будет 8 цифр):
while len(r)<8:
    r ='0' + r
Что мне нужно для закрепления этого задания:
1. Вспомнить как работать со строками в питоне!
2. Пробежаться по всей теории этого задания через какое-то время
3. прорешать до конца года 30 заданий на время (4 минуты)


# Задание №6!
Работа с модулем turtle, построение(в увеличенном масштабе, чем изначально полагает программа) с помощью черепахи разных фигур на осях х и y, дальнейшее расставление точек на этих осях и их подсчет.
Что мне нужно для закрепления этого задания:
1. перечитать конспекты по этому модулю turtle 
2. попрактиковаться в разных вариантах этого номера (с сайта Полякова)
3. прорешать до конца года 10 заданий
4. выучить код, который будет сам читать количество точек в фигуре
5. посмотреть возможности решения этого номера через "Кумир"(в 11 классе)

# Задание №7
Изображения:
Количество цветов переводим в глубину кодирования(представляем в виде 2 в какой-то степени), уможаем на объём изображения(одну сторону умножаем на другую) и переводим в необходимую единицу.
Объём изображение = глубина изображения * размер изображения / на 2^13 чтобы получить биты.
Биты ужимаются под объем изображения, они ВСЕГДА округляются в меньшую сторону и идут в степень для определения количества цветов
Что мне нужно для закрепления этого задания:

# Задание №8
Комбинаторика каких-то слов 
Что мне нужно для закрепления этого задания:
1. прорешать 10 заданий до конца года

# Задание №9
Тоже работа с xl-вскими таблицами, как и в 3 задании, но с большим количеством строк и проверкой чисел из них на некоторые условия.
Что мне нужно для закрепления этого задания:1
1. разобраться в тонкостях этого задания 
2. прорешать 20 заданий до конца года

# Задание№10
Работа с текстами, поиск количества определенных слов
В ворде ctr+F, слева от поиска стрелочка вниз, параметры (толко слово целиком - фикстрованная форма слова в условии; учитывать регистр - только слово маленькими буквами)
Ставим пробел перед словом, прежде чем искать его количество ставим пробел (если просят сочитание букв + еще какие то буквы, то никакого пробела!!)
Внимательно читаем условие, если в нем сказано, что нужно найти слова только в произведении, то игнорируем слова из аннотаций, названий и тд. Берём только слова, которые написал автор
Что мне нужно для закрепления этого задания:
1. прорешать 20 заданий до конца года

# Задание №11
Необходимо вычислить количество информации какого-то кода из условия (столько-то символов умножаем на такой-то объём одного символа, который можно узнать вместив объём всего алфавита(количества символов) в какую-то СТЕПЕНЬ двойики) и получим ответ в битах.) 
Что мне нужно для закрепления этого задания:
1. прорешать 10 заданий до конца года

# Задание №12!
Исполнитель редактор. Создав некую строку из условия, проверяем её на наличие конкретных символов и заменяем их на что-то другое. Либо сразу же меняем одну комбинацию чисел на другую.
Если в задании указано количество символов в ЛЮБОМ порядке, можно написать переменную, указав символы в угодном виде. Если количество символов неизвество, то перебирае их возможное количество циклами.
for a1 in range(50):
    for a2 in range(50):
        s = '1' * a1 + '2' * a2
Далее колчество символов можно узнать методом count
А если порядок символов неизвестен но играет значение, то:
import itertools
a = list(itertools.product('12', repeat = 16)), где 12-символы строки, 16 - их количесвто
for i in a:
    s = ''.join(i)#делвем строку из всех символов
    if s.count('1') == 12 and s.count('2') == 4:
        #расписали все условия задачи, выполняем сам код
1) s = s.replace('111', '22', 1)#не забываем про последниф аргумент, который указвает количество замен
2) for i in range(2, 1000):#перебираем возможное количество каких-то символов(здесь 8)
       s = i*'8'#создаём строку из этих подряд идущих символов
3) mnozestvo = set()#создаём множество, с которым будет работать в дальнейшем
   mnozestvo.add(s)#добавляем в наше множество аргументы строки, ВСЕ ДУБЛИКАТЫ ЭТИХ АРГУМЕНТОВ ПРОПУСКАЮТСЯ
4) print(sum([int (i) for i in s]))#переводим строку в целочисленную и сразу же подсчитываем сумму её элементов
5) max = 0#создаём переменную, с которой позже будем сравнивать некоторые данные
   if s.count('1')>max:#сравниваем количество единиц в переменной s с максимальным числом этих единиц, встреченных ранее 
       max = s.count('1')#присваиваем переменной max самое большое встреченное количество единиц 
   min_i = i#записали то количество единиц, которые и дали нам max
6) def prost(x):#создаём функцию для того, чтобы узнать простое ли пеед нами число(делятся только сами на себя и на еденицу(3, 7))
       for d in range(2, round(x ** 0.5) + 1):# ищем различные делители числа от 2 до корня из этого числа, дабы сузить круг поиска(если корень из числа не имеет других делителей, то и само число их не имеет)
           if x % d == 0:#проверяем наше условие, и если оно выполняется, то число нам не подходит
               return False
       return True
7) summ = sum([int(i) for i in s])#присваиваем этой переменной сумму всех элементов нашей строки
   if prort(summ) == True and summ in range(100, 1000):#проверяем нашу сумму на 2 условия (1-суммма чисел это простое число; 2- сумма чисел это трёхзначное число)
       print(n)
8) if sum(map(int, s)) > maxcnt:
    maxcnt = sum(map(int, s))
Что мне нужно для закрепления этого задания:
1. прорешать 10 заданий до конца года

## Задание №13!
Работа с IP адресами. Т.к. задание новое, нужно узнать что будет на самом экзе, выучить теорию по адресам
Что мне нужно для закрепления этого задания:

# Задание №14!
Подсчёт каких-то чисел в разных степенях и их последующий перевод в другую систему счисления и подсчёт каких-то чисел в полученном результате. Необходимо определить внимание на разные типы этого задания и изучить шаблоны выполнения каждого из них. Байты разделены точками. Количество адресов - 2 ^ количество нулей в полученной маске. А количество пользоватилей - (тоже самое число - 2), т.к. 2 адреса (все нули и все единицы заняты)
Нули - адрес сети, еденицы(идут только после 0) - хост(номер компа в этой сети). Произведение цифр этих двух списков чисел в двоичной системе - поразрядная конъюнкция(получаем полный адрес сети)
Что мне нужно для закрепления этого задания:
1. прорешать 10 заданий до конца года
2. научиться решать его как в проге так и вручную

# Задание №15!
Есл в условии функция должна быть тождественно ложна, то прописываем это в функции all(f(x, A) == False)
(1. Дел;2. Поразрядная конъюнкция(&);3. Графики(2 вложенных цикла);4. Отрезки(меняем А, добвляя туда элемент или убирая его(in/not in);5. Гибрид))
0. (Неравенства)Координатная плоскость (создание функции del, в которую переписывается условие задния через функцию return). Далее перебираем все возможные А, совлюдая условие, в этом А через функцию all перебираем по предыдущей функции дел все x и y  
1. (Делимость) У меня ниче не получилось
2. (Побитовая конъюнкция) Все кайф, как и в первом, только знак & 
3. (Отрезки) Также создаём функцию, но в неё уже записываем длины отрезков (их увеличиваем на 4 и делим каждое из чисел на 4 с целью увидеть пи ответе какие числа не попали в него([x/4 for x in range(14*4, 23*4+1)])) и само условие. Далее перебираем числа х от самого маленького числа из условия до самого большого на отрезке. После проверяем функцию от t(что является x/4)и считаем числа, которые полностью попали в ответ.
4. (Множества)
Что мне нужно для закрепления этого задания:
1. прорешать 10 заданий до конца года
2. Научиться решать эт задания руками!!

# Задание №16!
Вычисление рекурентных выражений. Определяем 2 вещи: условие окончание рекурсии, сама рекурентная форма(вызывает саму себя только с другими функциями)
Что мне нужно для закрепления этого задания:
1. изучить стек в питоне(последний пришёл, первый ушёл)
2. изучить блок try в питон
3. прорешать 10 заданий до конца года

# Задание № 17!
Работа с текстовыми файлами, составление алгоритма числовой последовательности. В этом задании необходимо обратить внимание на условие, по котоому отсеиваюся числа из списка и аккуратно переписать его.
with open('путь, имя файла'(если в той же директории, просто имя))
s = [int(x) for x in open('имя файла')]
# f = open('имя файла')
# l = [int(i) for i in f]
Что мне нужно для закрепления этого задания:

# Задание №18
Выстраивание маршрута по xlвским таблицам, собирая как можно большие значения в ячейках, передвигаясь по условию
Найти и выделить, заменить
Вставить, форматирование
Заполнить олько значение
Что мне нужно для закрепления этого задания:

# Задание № 19-21
Руками: находим позиции, которые дают выйгрыш за 1 ход (итоговое значение делим на самый большой ход), проигрыш и выйгрыш за 2 хода
Ексель: оформляем условие в виде таблицы, 
Прога: 
def WIN1(s):#19
    return s+1 >= 129 or s*2 >= 129
def LOSS1(s):
    return(not(WIN1(s))) and WIN1(s+1) and WIN1(2*s)
def WIN2(s):#20
    return LOSS1(s+1) or LOSS1(2*s)
def LOSS2(s):#21
    return WIN1(s+1) and WIN2(s*2) or WIN1(2*s) and WIN2(s+1)

for s in range(1,129):
if LOSS2(s):
    print(s)
Что мне нужно для закрепления этого задания:

# Задание № 22
В таблице прописываем свремя начала выполнения и продолжительность выполнения всем процессов
Решение ВПРом:
Данные -> текст по столбцам -> разделитель (;) -> заполнить табличку с началом/концом -> в строке, которая зависит от дургих строк указать функцию: 
МАКС(ВПР(IDпроцессов от которых зависим(1); A:F(вся таблица);6(номер столбца окончания);0)ВПР(IDпроцессов от которых зависим(2); A:F;6;0))->
заполняем столбик конца - делаем таблицу с числами(до последней секунды) и заливаем соответствующие секунды не включительно для каждой строки
если в задаче можно ставить проессы паралельно, то двигаем независимые прогессы так, чтобы было как можно больше прогессов вместе
Что мне нужно для закрепления этого задания:

# Задание № 23
Рекурсия:
def F(st, fin):
    if st == fin:#никуда не сдвинулись
        return 1
    if st < fin:#двинулись назад
        return 0
    if st == 23:#
        return 0
    s = sum([int(t) for t in str(st)])
    return F(st-1, fin) + F(st-s, fin)
print(F(42, 11))

# Заание #№24 
f = open("")
s = f.readline()
s = s.replace("", "")
a = s.split()#разделяем строку по пробелу
print(len(max(a, key = len)))#подсчитываем максимальную длину полученных строк, key - критерий подсчёта
Что мне нужно для закрепления этого задания:

# Задание №25
С тех пор как оно стало весить 1 балл на егэ были одни маски, которые решаются по шаблону:
from fnmatch import *
for x in range(1, 10**9)#для ускорения цикла здесь можно сразу пройтись только по тем числам, которые подходят условию (если нам нужны те, что делятся на 159, то (159< 10**9, 159))
    if fnmatch(str(x), "2?1*67"):#эта функция сразу подгоняется число под условие (в ней ?-один символ, *-несколько/пропуск)
        print(x, x//159)
Если в задании намудрили и поменяли вопрос и звёздочку по значениям, то работаем со срезами:
if str(x)[0] == "2" and str(x)[2] == "1" and str(x)[-2] == "6" and str(x)[-1] == "7"
Что мне нужно для закрепления этого задания:

# Задание №26
1. Прога:
f = open()
s, n = map(int, f.readline().split()) 
for j in f:
    korobki.append(int(s))
korobki.sort()
for i in range(len(korobki)):
    if sum(korobki_sudno) + korobki[i] <= s:
        korobki_sudno.append(korobki[i])

# Задание №27
s.sort(reverse=True)#сортировка по убыванию
Типы задач:
1. на пары/тройки
2. на мак суммы/произведения
3. на количество сумм/произведения(кратные/некартные и тд)
4. на подпоследовательности
5. на магистрали

f = open('filename.txt')
n = int(f.readline)#считываем первую строку в файлке
a, b = map(int, s.split()) #применяем функцию int на весь список f используя map(предварительно цикл for s in range n) 
Что мне нужно для закрепления этого задания: