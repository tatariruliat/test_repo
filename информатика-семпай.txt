Подготовка к ЕГЭ по информатике (18.05.22-...)

		Заметочки:
*просмотреть эти задания и дописать их: 1, 3, 5(прога), 6(ну и хуета), 7(дохуя теории), 9, 10, 18
*написать все коды в пучарме, дописывая коменты, вставляя ссылки на каждый код в этом файле
*попробовать напиать каждое задание и узнать, какие мне не понятны

Моментики, которые я не поняла/мне нужно уточнить с Саней:
	1. какой язык и среда програмирования будет доступна на экзамене в нашей области. 
	2. хто я
	3. президент ухраины
	4. а хто ты?
	5. после этой шутки я - иноагент
	6. бля а если ЕГЭ ваще отменят...
	
1. Использование и анализ информационных моделей (таблицы, диаграммы, графики)?
ебучие задачки Шерлока
	
2. Анализ таблиц истинности логических выражений(1)!
Обозначения логических операций:
	¬/~ A, не A (отрицание, not)
	A /\ B, A и B (конъюнкция, and)
	A \/ B, A или B (дизъюнкция, or)
	A → B, импликация (следование, <=)
	A===B, (равносильность, A==B)
	A º B, эквивалентность (равносильность, A!=B)
Порядок выполнения:
	*сперва пишем print('x y z w'), затем вводим цокл for для каждой избукв (for x in range(2))(2-потому что диапозон только 1/0)
*если в выражении нет скобок, сначала выполняются все операции «НЕ», затем – «И», затем – «ИЛИ», «импликация», и самая последняя – «эквивалентность»
	*после записи самого выражения через команду if(), нужно записать ответ, равный функции F (==1/0)
	*после получениия ответа, логически сопоствляем каждый столбец (x, y, z, w) вне зависимости от порядка цифр в полученном ответе!! при этом можно смореть на данные других, уже ивестных букв, например: при z = 1 нужно, чтобы y = 0, поэтому второй столбец – это y (т. к. у только у него в данной строчке 0)
	*в ответе пишем всегда буквы только в том порядке, в котором до этого они стояли в столбцах
Закрепить:
	1. выучит логические обозначения
	2. Прорешать немонотонные функции и разные задачи
	
3. Сортировка базз днных?
буду чекать в самом конце

4. Кодирование и декодирование данных(0)!
Для кодирования данных используем бинарные деревья (начало только 1/0), при этом соблюдая:
	· условие ФАНО (или обртное ему), это занчит, что ни одна буква не может являться началом другой 				буквы(например: Б-10, следовательно, В-не может быть 101/100 и т. д.)
	· если двоичный код НЕРАВНОМЕРНЫЙ,то слова будут разной длины, и наоборот
	· для наиболее часто встречающейся буквы-подбирать наиболее краткие кодовые слова
	
5. Выполнение и анализ простых данных(2)!
	1. Вручную:
		*переводим число R в двоичную систему исчесления (bin()) на консоли в питоне
		*проверяем,подходит ли это число по условию (наприер: если в первончальном числе (N)нечётное кол-во единиц, то мы дописываем одну единицу. При 2 проверке берём уже новое число с последней единицей и пересчитываем их. Т. к. кол-во единиц теперь четное, дописываем 0. Если число R подходит, как результат работы алгоритма,то берём его)
		*переводим новое число в 10-чную систему исчисления (int('10100', 2)) на консоли
	2. Прога:
		сосет хуй

6. Анализ программы с циклом????
Порядок действий:
	*с добавлением цикла for i in range (s=i) переписываем данную программу
	*дописываем функцию if с нужным условием из задачи (например: if n==64; print(i))
	*выбираем нужный ответ из представленных 
блять я нихуя не понимаю почему везде разные задачи ебись оно конём 
нужно вернуться и уточнить

7. 1)Кодирование растровых изображений 2)Кодирование звука. Скорость передачи информации 3)Определение скорости передачи информации при заданной пропускной способности канала?
1)Теория:
· для хранения растрового изображения нужно выделить в памяти I = N · i битов, где I - объём памяти, N – количество пикселей и i – глубина цвета (разрядность кодирования)
· количество пикселей изображения N = произведение ширины рисунка на высоту (в пикселях)
· глубина кодирования – это количество бит, которые выделяются на хранение цвета одного пикселя
· при глубине кодирования i битов на пиксель код каждого пикселя выбирается из 2 в степени i возможных вариантов, поэтому можно использовать не более 2 в степени i различных цветов
· нужно помнить, что
1 Мбайт = 1000000 байт = 8000000 бит,
1 Кбайт = 1000 байт = 8000 бит
2) Теория:

3) Теория:

8. Кодирование данных, комбинаторика, системы счисления(2)!
	Вручную:
		*перевести данные буквы в соответствующие цифры (например: А, Б, Ц - 0, 1, 2 и т. д.)
		*подставляем полученную запись под подходящую систему счисления (по кол-ву полученных букв) и находим нужную запись по её номеру (123 в троичной системе счисления)
	Прога:
		*вводим 3 переменные: LETTERS, в которую вписываем все данные нам буквы в алфавитном порядке ('АГОЯ'), переменную s, в которую в дальнейшем впишем ответ(s =[]), и переменную n=0, с которой начнётся отсчёт
		*далее вписываем условие для каждой из букв (for a in LETTERS:, for b in LETTERS: и т. д.)
		*для начала отсчёта (n+=1), после чего можем идти разными путями:
		*1)для поиска определённого сочетания букв пишем: (s.append(a+b+c+d)),(print(s.index('ОЯГА')))
		*2)для поиска определённого места из списка пишем: (if n == 215:), (print((a + b + c + d)))
9. Встроенные функции в электронных таблицах?
потом чекну

10. Поиск слов в текстовом документе?
тоже потом

11. Вычисление информационного объема сообщения(0)!
Порядок действий:
	*N = кол-во ВСЕХ данных символов (например: 9 (а,б,в,г,д,е,ё,ж,з))
	*N = 2 в степени i, где i - кол-во бит для храния одного символа (i = 4 бита(мы округляем в большую сторону))
	*узнав i перемножаем его с кол-вом символов в условии (например: пароль состоит из 15 символов)(4 * 15 = 60 бит)
*переводим всё в байты при необходимости(60: 8 = 8 байт)
	*умножаем результат на кол-во паролей (8*25 = 160)
	
12. Выполнение алгоритмов для исполнителя(2)!
Порядок действий:
	*вводим переменную s,вписывая туда данное условие(например: s = '9' * 127)
	*пишем цикл while с данными в проге условиями, каждый раз прописывая нужную переменную s(while '333' in s or '999'in s:)
	*далее вписываем условия if (333 in s) и else, приравнивая s = s.replase('333', '01', 1)(чтобы сменить последовательность цифр 333 на 01 ОДИН раз слева)
	*далее пишем (print (s)), если нам необходимо найти новую запись строчки 

13. Поиск путей в графе(0)!
читаем условие и зачёркиваем пути,которые нам не подхдят (например: все пути, которые не проходят через город Д)
считаем каждую букву отдельно (Г = Б + В, 1 + 2 = 3, 2 - т.к. в город В ведут 2 дороги(1 из А, 1 из Б))

14. Позиционные системы счисления(1)!
Обозначения:
	4 в с тепени 2020 - 4 ** 2020
	bin - перевод числа в 2-ичную систему
	oct - перевод числа в 8-ричную систему
	hex - перевод числа в 16-ричную систему
Порядок действий: 
	1)Для поиска кол-ва каких-то цифр в уравнении, без перевода в сис. счисления пишем всё в одну строчку: 
(print(bin(4 ** 2020 + 2 ** 2017 - 15).count('1')))

	2)Для поиска определённых цифр в 2, 8, 16 сис. счисления(в данном случае в 8): 
	вводим переменную x = 64**10 + 2**90 - 16
print( oct(x).count('7') )

	3)Чтобы найти кол-во цифр с определённой сис. счисления:
ну, ээээ, эм, эээ, ну типа лол, ну типаааа.. ЭЭЭЭЭ
	в переменную х вписываем данное уравнение
	вводим переменную k = 0
	запускаем цикл while x > 0:
		if x % 9 == 8 (8 - это последняя цифра в 9-ричной сис., тут мы )
			k += 1 (берём следующее число и тоже его делим)
		х //= 9 отрезаем цифру, чтобы цикл не был бесконечныл лол ну типа
print(k)

15. Основные понятия математической логики
Логические обозначения:
	¬ (A /\ B) = ¬ A \/ ¬ B
	¬ (A \/ B) = ¬ A /\ ¬ B
	¬/~ A, не A (отрицание, not)
	A /\ B, A и B (конъюнкция, and)
	A \/ B, A или B (дизъюнкция, or)
	A → B, импликация (следование, <=)
	x E P, х принадлежит Р (1 <= х <= 4)(т. к. Р = [1; 4])
	A===B, (равносильность, A==B)
ля чё зв херь 

16.Рекурсия. Рекурсивные процедуры и функции(2)
Ручки, сучка:

Прога:
создаём функцию (def f(n):)
далее прописываем данные условия  if n == 1:
после чего пишем return 1(приравниваем условие к результату)
выписывая остальные условия через else:
пишем ответ: print(f(26))

17.Перебор последовательности целых чисел. Проверка делимости(1)
Порядок действий:
создаём txt файл 
в коде пишем with open('17.txt') as f:
добавляем генератор списка: numbers = [int(x)for x in f](преобразуем каждую строку в целое число и проходимся по ним)
создаём пустой список s = []
перебираем весь список по парам: for i in range(1, len(numbers)):
проверяем по нужным условиям: if number[i] % 3 == 0 or numbers[i - 1] % 3 == 0(проверяем соседа)
если условие верно, то мы в список s вписываем сумму этих двух чисел: s.append(numbers[]i + numbers[i - 1])
находим кол-во таких элементов, и максимальную сумму: print(len(s), max(s))

18.Динамическое программирование(нельзя решить питоном)(0)
решается с помощью электронных таблиц((((

19. 20. 21. Теория игр. Поиск выигрышной стратегии(0)(!)
Начертив бинарное дерево:
19. устно пораскинув мозгами, ищем оптимальное число для следующего хода, следуя условиям
20. подгоняем предыдущую схемку, учитывая ВСЕ возможные команды, данные нам в условии 
21. учитывая все вышеперечисленный данные, делаем вывод о выйгрышных позициях для нужного игрока(например: если при s = 7/13 игрок выигрывает в любом случае через 1 ход, тогда подставляем 12, т.к. в одном из вариантов, он проиграл)

22.Анализ программы, содержащей подпрограммы, циклы и ветвления(2)
Вручную:
берём любое число для примера х
прогоняем его через данный данный нам цикл, по ответам понимаем за что в этом цикле отвечают переменные 
	например: 
	Q = 9
	L = 0
	while x >= Q:
		L +=1
		x = x - Q
в этом примере L отвечает за пересчёт кол-ва проведения циклов, а Q просто 9 

Прога:
Порядок действий:
копируем данный нам в задаче код, стираем значение х, стираем последний print
оформляем полученный код в функцию def f(x)
вводим новый цикл, устанавливая условия:
	while f(x) != (11,3)(пока цикл f(x) НЕ будет равен)
		x += 1 (увеличиваем на 1)
	print(x)

23.Динамическое программирование(1) - это решение сложной задачи, путём сведения её к более простым 
Порядок действий:
	пишем фунцию def k(x,y):, где х - первое данное нам в условии число, а y - второе
	если первое число в условии меньше второго, пишем условие, при котором функция ничего на не вернёт:
	if x > y:
        return 0
если в ответ нужно написать траекторию пути без конкретного числа, то в первой строчке добавляем (if x > y or y == 0:)
	повторяем тоже самое с оставшимся условием:
	if x == y:
        return 1
	далее выписываем 3 условие, включая в него возврат предыдущих и суммируя их(бля, не спрашивайте)
    if y % 2 == 0:
        return k(x, y-1) + k(x, y-2) + k(x, y // 2)
	затем пишем первые 2 условия отдельно (нет, вопросы всё еще не принимаются)
    return k(x, y - 1) + k(x, y - 2)
	если нужно просто написать ответ, то пишем (print k(30, 46))
	если нужно выписать в ответ траекторию программы, содержащую конкретное число:
	print(k(3, 10) * k(10, 12))

24.Обработка символьных строк(1)
Порядок действий ааа:
добавляем файл в одну директорию с нашим кодом и открываем его как единый объект (строку):
with open('24.txt') as f:
читаем эту строку и переименовываем 
	s = f.readline()
далее вводим 2 переменные (1 - подсчёт нужных нам символов, 2 - их максимальное кол-во)
	k, kmax = 1, 1
считываем все символы от первого до конца строки
	for i in range(1, len(s)):
для пересчёта конкретных символов, идущих подряд, рассатриваем один символ(например под омером 1), потом предыдущий(0) и если они оба являются буквой А, тогда к переменной k прибавляем  1
        if s[i] == s[i-1] == 'A':
			k += 1
в переменную kmax вписываем максималное кол-во переменной k
			kmax = max(kmax,k)
если этот порядок прирывается, то начинаем счёт сначала
		    else:
				k = 1	
выписываем максималное кол-во нужного символа подряд
print(kmax)
25.Обработка целых чисел, делителя числа
бляха ну и жесть((((((((((((

согласна, ну его нахуй


26.Обработка массива целых чисел из файла



27. Обработка последовательностей





